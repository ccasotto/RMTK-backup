# -*- coding: utf-8 -*-
"""
Created on Mon Sep 22 18:16:12 2014

@author: chiaracasotto
"""

import numpy as np
from common.get_Sc_bt import spo2ida
from common.get_Sc_bt import simplified_bilinear
from common.get_Sc_bt import DFfragility
from spo2ida_based.spo2ida_allTfunction import spo2ida_allT
from spo2ida_based.get_spo2ida_parameters import get_spo2ida_parameters
from common.damage_to_loss import damage_to_loss

pw = 1
filletstyle = 3

def vulnerability_process(vuln, an_type, T, Gamma, w, dcroof, SPO, bUthd, noBlg, g, MC, Sa_ratios, plot_feature, N, Tc, Td):
    if vuln == 1:
        plotflag,linew,fontsize,units,iml = plot_feature[0:5]
        LR50s = []
        bLRs = []
        for blg in range(0,noBlg):
            LRs = []
            if an_type != 1:
                if an_type == 0:
                    # Ruiz-Garcia Miranda's method the uncertainty in the damage criteria is already included in the total dispersion in a simplified way
                    [SaT50, bTSa] = simplified_bilinear(T[blg], Gamma[blg], dcroof[blg], SPO[blg], bUthd[blg], g)
                else:
                    [mc,a,ac,r,mf] = get_spo2ida_parameters(SPO[blg], T[blg], Gamma[blg]) # Convert MDoF into SDoF
                    [SaT50,bTSa] = DFfragility(T[blg], Gamma[blg], dcroof[blg], SPO[blg], bUthd[blg], mc, r, g, Tc, Td)
                # Conversions
                SaTlogmean_av, bTSa_av = np.log(SaT50)*Sa_ratios[blg], np.array(bTSa)*Sa_ratios[blg]
                LR50 = damage_to_loss(SaTlogmean_av,bTSa_av,iml,linew,fontsize,units)
                LRs.append(LR50)
            else:
                # Vamvatsikos and Cornell's method
                if np.array(bUthd[blg]).any() > 0: 
                # If only some damage criteria have uncertainty
                    dc_sample = np.zeros_like(dcroof[blg])
                    # Monte Carlo realisations of damage criteria e derivation of fragility curves 
                    # for each sample, mean loss ratios are computed at each IML from all samples 
                    for i in range (0,MC):
                        for j in range(0,len(dcroof[blg])):
                            if bUthd[blg][j]>0:
                                dc_sample[j] = np.random.lognormal(np.log(dcroof[blg][j]),bUthd[blg][j],1)
                            else:
                                dc_sample[j] = dcroof[blg][j]               
                        [mc,a,ac,r,mf] = get_spo2ida_parameters(SPO[blg], T[blg], Gamma[blg])
                        [idacm, idacr] = spo2ida_allT(mc,a,ac,r,mf,T[blg],pw,[0],filletstyle,N,linew,fontsize)
                        [SaT50, bTSa] = spo2ida(idacm, idacr, mf, T[blg], Gamma[blg], g, dc_sample, SPO[blg], np.zeros_like(bUthd[blg]), MC)
                        # Conversions
                        SaTlogmean_av, bTSa_av = np.log(SaT50)*Sa_ratios[blg], np.array(bTSa)*Sa_ratios[blg]                  
                        LRs.append(damage_to_loss(SaTlogmean_av,bTSa_av,iml,linew,fontsize,units))
                else: 
                # If any damage criteria have uncertainty
                    [mc,a,ac,r,mf] = get_spo2ida_parameters(SPO[blg], T[blg], Gamma[blg])
                    [idacm, idacr] = spo2ida_allT(mc,a,ac,r,mf,T[blg],pw,[0],filletstyle,N,linew,fontsize)
                    [SaT50, bTSa] = spo2ida(idacm, idacr, mf, T[blg], Gamma[blg], g, dcroof[blg], SPO[blg], bUthd[blg], MC)
                    # Conversions
                    SaTlogmean_av, bTSa_av = np.log(SaT50)*Sa_ratios[blg], np.array(bTSa)*Sa_ratios[blg] 
                    # Reconvert to median and dispersion
                    LRs.append(damage_to_loss(SaTlogmean_av,bTSa_av,iml,linew,fontsize,units))
            # Define Vulnerability curve for each building
            LR50s.append(np.mean(LRs,axis = 0))
            bLRs.append(np.std(LRs, axis = 0))
            
        # Combine the Loss Ratios of each building in a single LR for each iml, 
        # with mean = mean(LRs) and std = std(LRs)
        lr = np.array(LR50s)
        bLRs = np.array(bLRs)
        LR50 = np.average(lr, axis=0, weights=w) # weighted mean
        w2 = np.array([np.repeat(ele,len(iml)) for ele in w])
        bLR = np.sqrt(np.sum(np.multiply(np.power(bLRs,2)+np.power(lr-LR50,2),w2),axis=0))
    else:
        LR50, bLR = [],[]
        
    return [LR50, bLR]